-- ==========================================
-- 团队邀请功能 - 数据库表结构
-- ==========================================

-- 团队邀请表
CREATE TABLE IF NOT EXISTS team_invitations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  team_id BIGINT REFERENCES teams(id) ON DELETE CASCADE,
  email VARCHAR(255) NOT NULL,
  invited_by UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL UNIQUE, -- 邀请令牌，用于确认邀请
  status VARCHAR(20) DEFAULT 'pending', -- pending, accepted, expired, cancelled
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL, -- 邀请过期时间（默认7天）
  accepted_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(team_id, email, status) -- 同一团队同一邮箱只能有一个待处理的邀请
);

-- 索引
CREATE INDEX IF NOT EXISTS idx_team_invitations_team ON team_invitations(team_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_email ON team_invitations(email);
CREATE INDEX IF NOT EXISTS idx_team_invitations_token ON team_invitations(token);
CREATE INDEX IF NOT EXISTS idx_team_invitations_status ON team_invitations(status);

-- 约束：状态值
ALTER TABLE team_invitations DROP CONSTRAINT IF EXISTS valid_invitation_status;
ALTER TABLE team_invitations ADD CONSTRAINT valid_invitation_status 
  CHECK (status IN ('pending', 'accepted', 'expired', 'cancelled'));

-- 启用 RLS
ALTER TABLE team_invitations ENABLE ROW LEVEL SECURITY;

-- RLS 策略
-- 查看：团队 owner 可以查看自己团队的邀请
DROP POLICY IF EXISTS "Team owners can view invitations" ON team_invitations;
CREATE POLICY "Team owners can view invitations" ON team_invitations
  FOR SELECT USING (
    team_id IN (
      SELECT id FROM teams 
      WHERE owner_id = auth.uid()
    )
  );

-- 创建：团队 owner 可以创建邀请
DROP POLICY IF EXISTS "Team owners can create invitations" ON team_invitations;
CREATE POLICY "Team owners can create invitations" ON team_invitations
  FOR INSERT WITH CHECK (
    team_id IN (
      SELECT id FROM teams 
      WHERE owner_id = auth.uid()
    )
    AND invited_by = auth.uid()
  );

-- 更新：团队 owner 可以更新邀请状态（取消邀请）
DROP POLICY IF EXISTS "Team owners can update invitations" ON team_invitations;
CREATE POLICY "Team owners can update invitations" ON team_invitations
  FOR UPDATE USING (
    team_id IN (
      SELECT id FROM teams 
      WHERE owner_id = auth.uid()
    )
  );

-- 删除：团队 owner 可以删除邀请
DROP POLICY IF EXISTS "Team owners can delete invitations" ON team_invitations;
CREATE POLICY "Team owners can delete invitations" ON team_invitations
  FOR DELETE USING (
    team_id IN (
      SELECT id FROM teams 
      WHERE owner_id = auth.uid()
    )
  );

-- 函数：生成邀请令牌
CREATE OR REPLACE FUNCTION generate_invitation_token()
RETURNS TEXT AS $$
DECLARE
  token TEXT;
BEGIN
  -- 生成一个随机的 UUID 作为令牌
  token := gen_random_uuid()::TEXT;
  RETURN token;
END;
$$ LANGUAGE plpgsql;

-- 函数：创建邀请（自动设置过期时间）
-- 注意：使用简化版本，避免栈溢出问题
CREATE OR REPLACE FUNCTION create_team_invitation(
  p_team_id BIGINT,
  p_email VARCHAR(255),
  p_invited_by UUID
)
RETURNS TABLE (
  id BIGINT,
  token VARCHAR(255),
  expires_at TIMESTAMP WITH TIME ZONE
) AS $$
DECLARE
  v_token VARCHAR(255);
  v_expires_at TIMESTAMP WITH TIME ZONE;
  v_invitation_id BIGINT;
BEGIN
  -- SECURITY DEFINER 函数中，禁用 RLS 以避免递归
  -- set_config 的第三个参数 true 表示只在当前事务中生效
  PERFORM set_config('row_security', 'off', true);

  -- 检查是否已有待处理的邀请（只检查这一项，避免复杂查询）
  -- 注意：团队成员检查移到 accept_team_invitation 函数中，避免栈溢出
  IF EXISTS (
    SELECT 1 FROM team_invitations 
    WHERE team_invitations.team_id = p_team_id 
    AND team_invitations.email = p_email 
    AND team_invitations.status = 'pending'
    AND team_invitations.expires_at > NOW()
  ) THEN
    RAISE EXCEPTION '该邮箱已有待处理的邀请';
  END IF;

  -- 生成令牌和过期时间（7天后）
  v_token := generate_invitation_token();
  v_expires_at := NOW() + INTERVAL '7 days';

  -- 插入邀请记录
  -- 禁用 RLS 后，INSERT 不会触发 RLS 检查，避免递归
  INSERT INTO team_invitations (team_id, email, invited_by, token, expires_at)
  VALUES (p_team_id, p_email, p_invited_by, v_token, v_expires_at)
  RETURNING team_invitations.id, team_invitations.token, team_invitations.expires_at
  INTO v_invitation_id, v_token, v_expires_at;

  -- 返回结果
  id := v_invitation_id;
  token := v_token;
  expires_at := v_expires_at;
  RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 函数：接受邀请
CREATE OR REPLACE FUNCTION accept_team_invitation(
  p_token VARCHAR(255),
  p_user_id UUID
)
RETURNS TABLE (
  team_id BIGINT,
  success BOOLEAN
) AS $$
DECLARE
  v_invitation RECORD;
  v_user_email VARCHAR(255);
BEGIN
  -- 禁用 RLS 以避免递归
  PERFORM set_config('row_security', 'off', true);

  -- 获取邀请信息
  SELECT * INTO v_invitation
  FROM team_invitations
  WHERE team_invitations.token = p_token
  AND team_invitations.status = 'pending'
  AND team_invitations.expires_at > NOW();

  IF NOT FOUND THEN
    RAISE EXCEPTION '邀请不存在或已过期';
  END IF;

  -- 获取用户邮箱
  SELECT auth.users.email INTO v_user_email
  FROM auth.users
  WHERE auth.users.id = p_user_id;

  IF v_user_email IS NULL OR v_user_email != v_invitation.email THEN
    RAISE EXCEPTION '邮箱不匹配';
  END IF;

  -- 检查是否已经是团队成员（在禁用 RLS 的情况下检查）
  IF EXISTS (
    SELECT 1 FROM team_members 
    WHERE team_members.team_id = v_invitation.team_id 
    AND team_members.user_id = p_user_id
  ) THEN
    -- 如果已经是成员，仍然更新邀请状态为已接受
    UPDATE team_invitations
    SET status = 'accepted',
        accepted_at = NOW()
    WHERE team_invitations.id = v_invitation.id;
    
    team_id := v_invitation.team_id;
    success := TRUE;
    RETURN NEXT;
  ELSE
    -- 添加为团队成员
    INSERT INTO team_members (team_id, user_id, role)
    VALUES (v_invitation.team_id, p_user_id, 'member')
    ON CONFLICT (team_id, user_id) DO NOTHING;

    -- 更新邀请状态
    UPDATE team_invitations
    SET status = 'accepted',
        accepted_at = NOW()
    WHERE team_invitations.id = v_invitation.id;

    team_id := v_invitation.team_id;
    success := TRUE;
    RETURN NEXT;
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 触发器：自动清理过期的邀请
CREATE OR REPLACE FUNCTION cleanup_expired_invitations()
RETURNS TRIGGER AS $$
BEGIN
  -- 将过期的邀请标记为 expired
  UPDATE team_invitations
  SET status = 'expired'
  WHERE status = 'pending'
  AND expires_at < NOW();
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器（每次查询时检查）
-- 注意：这只是一个示例，实际生产环境建议使用定时任务（cron job）
CREATE TRIGGER check_expired_invitations
AFTER INSERT OR UPDATE ON team_invitations
FOR EACH STATEMENT
EXECUTE FUNCTION cleanup_expired_invitations();
